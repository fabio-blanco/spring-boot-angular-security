# Spring Boot Angular Security Sample Project #

This project is a simple sample of how to use Spring Boot with Security and Angular.

The Spring Security is configured with basic authentication using almost the default 
authentication configuration. Therefore, use the user 'user', and the password randomly
generated by spring boot in its initialization so find it on the console.

I've based almost all Spring Security and Angular integration on the 
[following article](https://spring.io/guides/tutorials/spring-security-and-angular-js/).

For the initial Spring Boot and Angular integration see 
[this sample project and instructions](https://github.com/fabio-blanco/spring-boot-angular-web).

## Spring Security with Angular How to ##

Create a Login Angular Component with a simple form and call login function on submit:

```html
<form role="form" (submit)="login()">
```

On the login function call a service that will communicate with the spring backend using the given
credentials to authenticate:

```typescript
//Simplified code
export class LoginComponent implements OnInit {
	
	//Credentials with information from the form on the template
  credentials = {username: '', password: ''};

  login(): void {
    this.generalService.authenticate(this.credentials, () => {
      this.router.navigateByUrl('/');
    });
  }

}
```

On the service call the backend user service that will only retrieve principal information as the
spring security will log the user in by the headers sent.

```typescript
//Simplified code
export class GeneralService {

  private resourceUrl = "/api";
  authenticated = false;

  constructor(private http: HttpClient) { }

  public authenticate(credentials, callback): void {
    const headers = new HttpHeaders(credentials ? {
      authorization: 'Basic ' + btoa(`${credentials.username}:${credentials.password}`)
    } : {});

    this.http.get(`${this.resourceUrl}/user`, {headers: headers}).subscribe(response => {
      this.authenticated = !!response['name'];
      return callback && callback();
    });
  }
}
```

The error handling was omitted for simplicity. See the source code for a more complete approach.

On the backend we need just to code a controller with the get mapping to address this call:

```java
// GeneralApiController.java
@GetMapping("/user")
public Principal user(Principal user) {
    return user;
}
```

It is just a trick. If the spring security allow the method execution we may assume the login was
successful and we have a principal user to give back to front end.


### Adding AJAX header to avoid basic authentication browser dialog popups ###

Because we are using basic authentication the api XHR requests (AJAX) can return a 401 response. 
To avoid this we need to send a special request header "X-Requested-With=XMLHttpRequest" 
([read this to learn more](https://spring.io/guides/tutorials/spring-security-and-angular-js/#_adding_default_http_request_headers)). 
In order to do this, create an Angular interceptor:

```typescript
@Injectable()
export class XhrInterceptor implements HttpInterceptor {

  constructor() {}

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<unknown>> {
    const xhr = request.clone({
      headers: request.headers.set('X-Requested-With', 'XMLHttpRequest')
    });

    return next.handle(xhr);
  }
}

```

And register this interceptor on AppModule:

```typescript
@NgModule({
 // ...
  providers: [
    {provide: HTTP_INTERCEPTORS, useClass: XhrInterceptor, multi: true}
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Spring security configuration ###

Some resource requests must be authorized without authentication from spring security to let
the app work and allow the user to be able to login. This is done by overriding the
spring security default configuration:

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.httpBasic()
                    .and()
                    .authorizeRequests().antMatchers("/index.html", "/", "/home",
                                                     "/login", "/main.js*", "/polyfills.js*",
                                                     "/runtime.js*", "/vendor.js*", "/styles.css*",
                                                     "/favicon.ico", "/api/initial-data").permitAll()
                                        .anyRequest().authenticated()
                    .and()
                    .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }
}
```

The last part of the security configuration refers to some csrf stuff, this is how we tell
spring security to send a cookie called "XSRF-TOKEN" to the Angular client, so it can now
make server requests by sending this token as header property called "X-CSF". This is a 
how we deal with Spring built-in CSRF protection mechanism in order to allow our logout
link to work.
The logout functionality we are using here is the default provided from Spring Security on
spring Boot, and we don't have to do nothing for it to work on server side. We
just call it from an Angular component:

```html
<!-- app.component.html -->
<li *ngIf="autenticated()"><a (click)="logout()">Logout</a></li>
```

```typescript
// app.component.ts
logout(): void {
  this.generalService.logout().pipe(
    finalize(() => {
      this.generalService.authenticated = false;
      this.router.navigateByUrl('/login');
    })
  ).subscribe();
}
```

On the service we just call the default logout url provided by spring security:

```typescript
public logout(): Observable<any> {
  return this.http.post('logout', {});
}
```

### A proper 404 landing page and avoiding browser routing errors ###

By default, Spring Security will return a 404 error page for any request that has not a matching
resource in one of its controllers and since we want to let the Angular deal with the html 5 
urls with its own Router functionality we have to tell spring to let Angular deal with unknown
resources (routes), otherwise we will not be able to refresh the browser without been redirected 
to the home.

To configure the Spring Web MVC layer to delegate unknown rote handling to Angular itself we may
add a resource handler that redirects all unknown rotes to `index.html` letting the routing job
to be done by the Angular Router:

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {

        registry.addResourceHandler("/**")
                .addResourceLocations("classpath:/static/")
                .resourceChain(true)
                .addResolver(new PathResourceResolver() {

                    @Override
                    protected Resource getResource(String resourcePath, Resource location) throws IOException {
                        Resource requestedResource = location.createRelative(resourcePath);
                        return requestedResource.exists() && requestedResource.isReadable() ?
                            requestedResource : new ClassPathResource("/static/index.html");
                    }
                });

    }
}
```

Now all existing routes will be properly addressed by Angular Routing mechanisms, even if we refresh the 
browser or call the full relative link directly. But when we do this with an unknown route we will
get a failure with a console error message in our browser. To solve this problem we should create a
proper NotFound Angular component with a default 404 error message:

```html
<!-- not-found.component.html -->
<div>

  <h1>Page not found (404)</h1>


  <p class="error-description">The requested URL {{unknownPath}} was not found on this server.</p>
  <p>Please, try to find the page you want by navigating with the menu!</p>

</div>
```

```typescript
// not-found.component.ts
@Component({
  selector: 'app-not-found',
  templateUrl: './not-found.component.html',
  styleUrls: ['./not-found.component.css']
})
export class NotFoundComponent implements OnInit {

  unknownPath: string

  constructor(private location: Location) {
  }

  ngOnInit(): void {
    this.unknownPath = this.location.path()
  }

}
```

... and route all unknown rotes to it:

```typescript
// app-routing.module.ts
const routes: Routes = [
  // ...
  { path: '404', component: NotFoundComponent},
  { path: '**', redirectTo: '/404'}
];
```

## Copyright and license ##

Code and documentation copyright 2021 Fabio M. Blanco. Code released under the
[MIT License](https://github.com/fabio-blanco/spring-boot-angular-security/blob/master/LICENSE)
